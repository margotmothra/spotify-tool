<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spotify Playlist Creator - Andy Shauf</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 50px auto;
            padding: 20px;
            background-color: #191414;
            color: #fff;
        }
        .container {
            background-color: #282828;
            padding: 30px;
            border-radius: 8px;
            position: relative;
        }
        .logo-container {
            position: absolute;
            top: 20px;
            right: 20px;
        }
        .logo-container img {
            height: 40px;
            width: auto;
        }
        button {
            background-color: #1db954;
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 16px;
            border-radius: 24px;
            cursor: pointer;
            margin: 10px 5px;
        }
        button:hover {
            background-color: #1ed760;
        }
        button:disabled {
            background-color: #535353;
            cursor: not-allowed;
        }
        #loginBtn.logged-in {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 6px 20px 6px 6px;
            background-color: #282828;
            cursor: default;
        }
        #loginBtn.logged-in:hover {
            background-color: #282828;
        }
        .profile-pic {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            object-fit: cover;
        }
        #status {
            margin-top: 20px;
            padding: 15px;
            border-radius: 4px;
            background-color: #333;
        }
        .success { color: #1db954; }
        .error { color: #e74c3c; }
        .info { color: #3498db; }
        input, textarea {
            width: 100%;
            padding: 10px;
            margin: 10px 0;
            background-color: #333;
            border: 1px solid #535353;
            color: #fff;
            border-radius: 4px;
            font-family: Arial, sans-serif;
        }
        textarea {
            resize: vertical;
            min-height: 80px;
        }
        label {
            display: block;
            margin-top: 15px;
            font-weight: bold;
        }
        .settings-section {
            background-color: #333;
            padding: 15px;
            border-radius: 4px;
            margin-top: 20px;
        }
        .settings-section h3 {
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 16px;
            color: #1db954;
        }
        .setting-group {
            margin-bottom: 15px;
        }
        .setting-group label {
            display: inline;
            margin-top: 0;
            font-weight: normal;
            margin-left: 8px;
            cursor: pointer;
        }
        .setting-group input[type="checkbox"],
        .setting-group input[type="radio"] {
            cursor: pointer;
            width: auto;
            margin: 0;
        }
        .radio-group {
            display: flex;
            gap: 20px;
            margin-top: 8px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="logo-container">
            <img src="assets/spotify-logo.png" alt="Spotify">
        </div>
        <h1>Spotify Playlist Creator</h1>
        <p>Create a complete artist discography playlist with smart deduplication</p>
        
        <label for="artistName">Artist Names (one per line or comma-separated):</label>
        <textarea id="artistName" placeholder="Enter artist names, e.g.:&#10;Andy Shauf&#10;Sufjan Stevens&#10;or: Andy Shauf, Sufjan Stevens">Andy Shauf</textarea>
        
        <label for="playlistName">Playlist Name:</label>
        <input type="text" id="playlistName" value="" placeholder="Auto-filled from artist names">

        <label for="playlistDescription">Playlist Description:</label>
        <input type="text" id="playlistDescription" value="" placeholder="Auto-filled from artist names">

        <div class="settings-section">
            <h3>Deduplication Settings</h3>

            <div class="setting-group">
                <div style="font-weight: bold; margin-bottom: 8px;">When duplicates are found, prefer:</div>
                <div class="radio-group">
                    <div>
                        <input type="radio" id="preferOlder" name="chronology" value="older" checked>
                        <label for="preferOlder">Older version (original release)</label>
                    </div>
                    <div>
                        <input type="radio" id="preferNewer" name="chronology" value="newer">
                        <label for="preferNewer">Newer version (deluxe/remaster)</label>
                    </div>
                </div>
            </div>

            <div class="setting-group">
                <input type="checkbox" id="keepAlternate" checked>
                <label for="keepAlternate">Keep alternate versions</label>
            </div>

            <div class="setting-group">
                <input type="checkbox" id="keepLive" checked>
                <label for="keepLive">Keep live/session recordings</label>
            </div>

            <div class="setting-group">
                <input type="checkbox" id="removeInstrumental">
                <label for="removeInstrumental">Remove instrumental versions</label>
            </div>

            <div class="setting-group">
                <input type="checkbox" id="removeRemix">
                <label for="removeRemix">Remove remixes</label>
            </div>

            <div class="setting-group">
                <label for="customBlacklist" style="display: block; margin-bottom: 5px;">Custom blacklist (comma-separated phrases to remove):</label>
                <input type="text" id="customBlacklist" placeholder="e.g., karaoke, demo, rehearsal">
            </div>
        </div>

        <div style="margin-top: 20px;">
            <button id="loginBtn" onclick="login()">Login with Spotify</button>
            <button id="createBtn" onclick="createPlaylist()" disabled>Create Playlist</button>
        </div>
        
        <div id="status"></div>
    </div>

    <script src="config.js"></script>
    <script>
        // Load Spotify credentials from config file
        const CLIENT_ID = SPOTIFY_CONFIG.CLIENT_ID;
        const CLIENT_SECRET = SPOTIFY_CONFIG.CLIENT_SECRET;
        const REDIRECT_URI = SPOTIFY_CONFIG.REDIRECT_URI;

        let accessToken = null;

        // Check if we're returning from OAuth
        window.onload = function() {
            const urlParams = new URLSearchParams(window.location.search);
            const code = urlParams.get('code');

            if (code) {
                getAccessToken(code);
            }

            // Restore form values from localStorage if they exist
            const artistInput = document.getElementById('artistName');
            const playlistInput = document.getElementById('playlistName');
            const descriptionInput = document.getElementById('playlistDescription');

            if (localStorage.getItem('spotifyPlaylistCreator_artistName')) {
                artistInput.value = localStorage.getItem('spotifyPlaylistCreator_artistName');
                playlistInput.value = localStorage.getItem('spotifyPlaylistCreator_playlistName');
                descriptionInput.value = localStorage.getItem('spotifyPlaylistCreator_playlistDescription');
                document.getElementById('customBlacklist').value = localStorage.getItem('spotifyPlaylistCreator_customBlacklist') || '';

                // Restore checkbox states
                const preferOlder = localStorage.getItem('spotifyPlaylistCreator_preferOlder') === 'true';
                document.getElementById('preferOlder').checked = preferOlder;
                document.getElementById('preferNewer').checked = !preferOlder;
                document.getElementById('keepAlternate').checked = localStorage.getItem('spotifyPlaylistCreator_keepAlternate') === 'true';
                document.getElementById('keepLive').checked = localStorage.getItem('spotifyPlaylistCreator_keepLive') === 'true';
                document.getElementById('removeInstrumental').checked = localStorage.getItem('spotifyPlaylistCreator_removeInstrumental') === 'true';
                document.getElementById('removeRemix').checked = localStorage.getItem('spotifyPlaylistCreator_removeRemix') === 'true';

                // Clear localStorage after restoring
                localStorage.removeItem('spotifyPlaylistCreator_artistName');
                localStorage.removeItem('spotifyPlaylistCreator_playlistName');
                localStorage.removeItem('spotifyPlaylistCreator_playlistDescription');
                localStorage.removeItem('spotifyPlaylistCreator_customBlacklist');
                localStorage.removeItem('spotifyPlaylistCreator_preferOlder');
                localStorage.removeItem('spotifyPlaylistCreator_keepAlternate');
                localStorage.removeItem('spotifyPlaylistCreator_keepLive');
                localStorage.removeItem('spotifyPlaylistCreator_removeInstrumental');
                localStorage.removeItem('spotifyPlaylistCreator_removeRemix');
            }

            // Auto-fill playlist name and description based on artist names

            function updatePlaylistFields() {
                const artistNames = artistInput.value
                    .split(/[\n,]+/)
                    .map(name => name.trim())
                    .filter(name => name.length > 0);

                if (artistNames.length > 0) {
                    const playlistName = artistNames.join(' + ') + ' - Complete';
                    playlistInput.value = playlistName;

                    const artistList = artistNames.join(', ');
                    const description = `Complete discography: ${artistList}`;
                    descriptionInput.value = description;
                }
            }

            artistInput.addEventListener('input', updatePlaylistFields);

            // Trigger initial auto-fill if there's a default value
            updatePlaylistFields();
        };

        function login() {
            // Save form values to localStorage before redirecting
            localStorage.setItem('spotifyPlaylistCreator_artistName', document.getElementById('artistName').value);
            localStorage.setItem('spotifyPlaylistCreator_playlistName', document.getElementById('playlistName').value);
            localStorage.setItem('spotifyPlaylistCreator_playlistDescription', document.getElementById('playlistDescription').value);
            localStorage.setItem('spotifyPlaylistCreator_customBlacklist', document.getElementById('customBlacklist').value);
            localStorage.setItem('spotifyPlaylistCreator_preferOlder', document.getElementById('preferOlder').checked);
            localStorage.setItem('spotifyPlaylistCreator_keepAlternate', document.getElementById('keepAlternate').checked);
            localStorage.setItem('spotifyPlaylistCreator_keepLive', document.getElementById('keepLive').checked);
            localStorage.setItem('spotifyPlaylistCreator_removeInstrumental', document.getElementById('removeInstrumental').checked);
            localStorage.setItem('spotifyPlaylistCreator_removeRemix', document.getElementById('removeRemix').checked);

            const scopes = 'playlist-modify-private playlist-modify-public';
            const authUrl = `https://accounts.spotify.com/authorize?client_id=${CLIENT_ID}&response_type=code&redirect_uri=${encodeURIComponent(REDIRECT_URI)}&scope=${encodeURIComponent(scopes)}`;
            window.location.href = authUrl;
        }

        async function getAccessToken(code) {
            updateStatus('Getting access token...', 'info');
            
            try {
                const response = await fetch('https://accounts.spotify.com/api/token', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                        'Authorization': 'Basic ' + btoa(CLIENT_ID + ':' + CLIENT_SECRET)
                    },
                    body: new URLSearchParams({
                        grant_type: 'authorization_code',
                        code: code,
                        redirect_uri: REDIRECT_URI
                    })
                });
                
                const data = await response.json();
                accessToken = data.access_token;

                // Fetch user profile
                const user = await fetchWebApi('v1/me', 'GET');

                // Update login button with user info
                const loginBtn = document.getElementById('loginBtn');
                loginBtn.disabled = true;
                loginBtn.classList.add('logged-in');

                const profileImage = user.images && user.images.length > 0
                    ? user.images[0].url
                    : 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"%3E%3Ccircle cx="16" cy="16" r="16" fill="%23535353"/%3E%3Cpath d="M16 8a4 4 0 1 0 0 8 4 4 0 0 0 0-8zm0 10c-4 0-8 2-8 4v2h16v-2c0-2-4-4-8-4z" fill="%23fff"/%3E%3C/svg%3E';

                loginBtn.innerHTML = `<img src="${profileImage}" alt="Profile" class="profile-pic"><span>Logged in as ${user.display_name}</span>`;

                document.getElementById('createBtn').disabled = false;
                updateStatus('✅ Logged in successfully! Ready to create playlist.', 'success');

                // Clean up URL
                window.history.replaceState({}, document.title, window.location.pathname);
            } catch (error) {
                updateStatus('❌ Error getting access token: ' + error.message, 'error');
            }
        }

        async function fetchWebApi(endpoint, method, body) {
            const res = await fetch(`https://api.spotify.com/${endpoint}`, {
                headers: {
                    Authorization: `Bearer ${accessToken}`,
                },
                method,
                body: JSON.stringify(body)
            });
            return await res.json();
        }

        async function searchArtist(artistName) {
            const data = await fetchWebApi(
                `v1/search?q=${encodeURIComponent(artistName)}&type=artist&limit=10`,
                'GET'
            );

            if (!data.artists.items || data.artists.items.length === 0) {
                return null;
            }

            // Try to find exact match first (case-insensitive)
            const exactMatch = data.artists.items.find(
                artist => artist.name.toLowerCase() === artistName.toLowerCase()
            );

            // Return exact match if found, otherwise return first result
            return exactMatch || data.artists.items[0];
        }

        async function getArtistAlbums(artistId) {
            let albums = [];
            let offset = 0;
            const limit = 50;
            
            while (true) {
                const data = await fetchWebApi(
                    `v1/artists/${artistId}/albums?include_groups=album,single,compilation&limit=${limit}&offset=${offset}`,
                    'GET'
                );
                albums.push(...data.items);
                
                if (data.items.length < limit) break;
                offset += limit;
            }
            
            return albums;
        }

        async function getAlbumTracks(albumId) {
            let tracks = [];
            let offset = 0;
            const limit = 50;
            
            while (true) {
                const data = await fetchWebApi(
                    `v1/albums/${albumId}/tracks?limit=${limit}&offset=${offset}`,
                    'GET'
                );
                tracks.push(...data.items);
                
                if (data.items.length < limit) break;
                offset += limit;
            }
            
            return tracks;
        }

        function isVariation(trackName) {
            // Check settings
            const keepAlternate = document.getElementById('keepAlternate').checked;
            const keepLive = document.getElementById('keepLive').checked;

            // Build pattern based on settings
            let patterns = ['acoustic', 'remix', 'demo', 'instrumental', 'radio edit', 'extended'];

            if (keepAlternate) {
                patterns.push('alternate');
            }

            if (keepLive) {
                patterns.push('live', 'session');
            }

            // Always check for remaster and version as they're common variations
            patterns.push('remaster', 'version');

            const variationsRegex = new RegExp(patterns.join('|'), 'i');
            return variationsRegex.test(trackName);
        }

        function normalizeTrackName(name) {
            return name
                .toLowerCase()
                .replace(/\s*[\(\[].*?[\)\]]\s*/g, '')
                .replace(/[^\w\s]/g, '')
                .trim();
        }

        async function getUniqueArtistTracks(artistIds) {
            const trackMap = new Map();
            const duplicates = [];

            // Get settings
            const preferNewer = document.querySelector('input[name="chronology"]:checked').value === 'newer';
            const removeInstrumental = document.getElementById('removeInstrumental').checked;
            const removeRemix = document.getElementById('removeRemix').checked;
            const customBlacklist = document.getElementById('customBlacklist').value
                .split(',')
                .map(phrase => phrase.trim().toLowerCase())
                .filter(phrase => phrase.length > 0);

            // Function to check if track should be filtered out
            function shouldFilterTrack(trackName) {
                const nameLower = trackName.toLowerCase();

                if (removeInstrumental && nameLower.includes('instrumental')) {
                    return true;
                }

                if (removeRemix && nameLower.includes('remix')) {
                    return true;
                }

                for (const phrase of customBlacklist) {
                    if (nameLower.includes(phrase)) {
                        return true;
                    }
                }

                return false;
            }

            for (const artistId of artistIds) {
                updateStatus(`Fetching albums for artist...`, 'info');
                const albums = await getArtistAlbums(artistId);

                for (let i = 0; i < albums.length; i++) {
                    const album = albums[i];
                    updateStatus(`Fetching tracks from ${album.name} (${i+1}/${albums.length})...`, 'info');
                    const tracks = await getAlbumTracks(album.id);

                    for (const track of tracks) {
                        // Check if track should be filtered out
                        if (shouldFilterTrack(track.name)) {
                            duplicates.push({
                                track: track,
                                duplicateOf: null,
                                album: album.name,
                                reason: 'Filtered by settings'
                            });
                            continue;
                        }
                        const normalized = normalizeTrackName(track.name);
                        const isVar = isVariation(track.name);
                        const key = `${normalized}_${isVar ? track.name : 'standard'}`;

                        if (!trackMap.has(key)) {
                            // Store track with album info
                            trackMap.set(key, {
                                track: track,
                                album: album,
                                releaseDate: album.release_date
                            });
                        } else {
                            // Found a duplicate - decide which to keep based on chronology
                            const existing = trackMap.get(key);
                            const existingDate = new Date(existing.releaseDate || '1900-01-01');
                            const newDate = new Date(album.release_date || '1900-01-01');

                            let shouldReplace = false;
                            if (preferNewer) {
                                shouldReplace = newDate > existingDate;
                            } else {
                                shouldReplace = newDate < existingDate;
                            }

                            if (shouldReplace) {
                                // Record the old one as duplicate and replace with new one
                                duplicates.push({
                                    track: existing.track,
                                    duplicateOf: track,
                                    album: existing.album.name
                                });
                                trackMap.set(key, {
                                    track: track,
                                    album: album,
                                    releaseDate: album.release_date
                                });
                            } else {
                                // Keep existing, record new one as duplicate
                                duplicates.push({
                                    track: track,
                                    duplicateOf: existing.track,
                                    album: album.name
                                });
                            }
                        }
                    }
                }
            }

            return {
                tracks: Array.from(trackMap.values()).map(item => item.track),
                duplicates: duplicates
            };
        }

        async function createPlaylist() {
            const artistInput = document.getElementById('artistName').value;
            const playlistName = document.getElementById('playlistName').value;
            const playlistDescription = document.getElementById('playlistDescription').value;

            if (!artistInput || !playlistName) {
                updateStatus('❌ Please enter both artist names and playlist name', 'error');
                return;
            }

            // Parse multiple artist names (split by newlines and commas)
            const artistNames = artistInput
                .split(/[\n,]+/)
                .map(name => name.trim())
                .filter(name => name.length > 0);

            if (artistNames.length === 0) {
                updateStatus('❌ Please enter at least one artist name', 'error');
                return;
            }

            document.getElementById('createBtn').disabled = true;

            try {
                // Search for all artists
                const artists = [];
                const artistNamesFound = [];

                for (const artistName of artistNames) {
                    updateStatus(`Searching for ${artistName}...`, 'info');
                    const artist = await searchArtist(artistName);

                    if (!artist) {
                        updateStatus(`⚠️ Artist "${artistName}" not found, skipping...`, 'error');
                        continue;
                    }

                    updateStatus(`Found: ${artist.name}`, 'info');
                    artists.push(artist);
                    artistNamesFound.push(artist.name);
                }

                if (artists.length === 0) {
                    updateStatus('❌ No artists found', 'error');
                    document.getElementById('createBtn').disabled = false;
                    return;
                }

                const user = await fetchWebApi('v1/me', 'GET');

                const playlist = await fetchWebApi(
                    `v1/users/${user.id}/playlists`,
                    'POST',
                    {
                        name: playlistName,
                        description: playlistDescription,
                        public: true
                    }
                );

                updateStatus(`Created playlist: ${playlist.name}`, 'info');

                const artistIds = artists.map(a => a.id);
                const result = await getUniqueArtistTracks(artistIds);
                const tracks = result.tracks;
                const duplicates = result.duplicates;

                updateStatus(`Found ${tracks.length} unique tracks from ${artists.length} artist(s). Adding to playlist...`, 'info');

                const trackUris = tracks.map(t => t.uri);
                for (let i = 0; i < trackUris.length; i += 100) {
                    const batch = trackUris.slice(i, i + 100);
                    await fetchWebApi(
                        `v1/playlists/${playlist.id}/tracks`,
                        'POST',
                        { uris: batch }
                    );
                    updateStatus(`Added tracks ${i + 1}-${Math.min(i + 100, trackUris.length)} of ${tracks.length}`, 'info');
                }

                // Display success message with duplicates info
                let successMessage = `✅ Success! <a href="${playlist.external_urls.spotify}" target="_blank" style="color: #1db954;">Open Playlist</a>`;

                if (duplicates.length > 0) {
                    successMessage += `<br><br><strong>${duplicates.length} duplicate tracks removed</strong>`;
                    successMessage += `<br><details style="margin-top: 10px;"><summary style="cursor: pointer; color: #1db954;">View removed tracks</summary><ul style="margin-top: 10px; max-height: 300px; overflow-y: auto;">`;

                    duplicates.forEach(dup => {
                        successMessage += `<li style="margin: 5px 0;">${dup.track.name} <span style="color: #888;">(from ${dup.album})</span></li>`;
                    });

                    successMessage += `</ul></details>`;
                }

                updateStatus(successMessage, 'success');

            } catch (error) {
                updateStatus('❌ Error: ' + error.message, 'error');
                console.error(error);
            } finally {
                document.getElementById('createBtn').disabled = false;
            }
        }

        function updateStatus(message, type) {
            const statusDiv = document.getElementById('status');
            statusDiv.innerHTML = message;
            statusDiv.className = type;
        }
    </script>
</body>
</html>

